// Copyright 2015 The OPA Authors.  All rights reserved.
// Use of this source code is governed by an Apache2
// license that can be found in the LICENSE file.

package jsonlog

import (
    "reflect"
    "fmt"
)

const (
    // note: iota is built into Go and is auto-incremented
    NULL = iota
    BOOLEAN = iota
    NUMBER = iota
    STRING = iota
    VARIABLE = iota
    REFERENCE = iota
    ARRAY = iota
    DICTIONARY = iota
)

// Set is a collection of objects that we can't use a map for.
type Set struct {
    Values []interface{}
    EqualFunc func(interface{}, interface{}) bool
}

// NewSet returns a new set
func NewSet(equal func(interface{}, interface{}) bool) *Set {
    s := Set{Values: make([]interface{}, 0), EqualFunc: equal}
    return &s
}

// NewKeyValueSet returns a set for KeyValue pairs
func NewKeyValueSet() *Set {
    f := func(x interface{}, y interface{}) bool {
        kvx := x.(*KeyValue)
        kvy := y.(*KeyValue)
        return kvx.Equal(kvy)
    }
    return NewSet(f)
}

// Add an element
func (s *Set) Add (x interface{}) {
    if !s.Contains(x) {
        s.Values = append(s.Values, x)
    }
}

// Contains returns true if the set contains element x
func (s *Set) Contains (x interface{}) bool {
    for _, elem := range s.Values {
        if s.EqualFunc(x, elem) {
            return true
        }
    }
    return false
}

// Length returns number of elements
func (s *Set) Length () int {
    return len(s.Values)
}

// Equal returns True if the 2 sets have all the same elements
func (set1 *Set) Equal (set2 *Set) bool {
    if len(set1.Values) != len(set2.Values) {
        return false
    }

    // TODO: reimplement natively so we don't use memory
    diff12 := set1.Difference(set2)
    if diff12.Length() > 0 {
        return false
    }
    diff21 := set2.Difference(set1)
    if diff21.Length() > 0 {
        return false
    }
    return true
}

// Difference returns a new set that has all the elements of set1 except those in set2
func (set1 *Set) Difference (set2 *Set) *Set {
    newset := NewSet(set1.EqualFunc)
    for _, elem := range set1.Values {
        if !set2.Contains(elem) {
            newset.Add(elem)
        }
    }
    return newset
}

// Location records a position in source code
type Location struct {
    File string
    Row int
    Col int
}

// NewLocation creates a new instance of a location
func NewLocation(file string, row int, col int) *Location {
    l := Location{File: file, Row: row, Col: col}
    return &l
}

// Term is an argument to a function
type Term struct {
    Value interface{}   // actual value, as represented by Go
    Kind int            // type of Term: one of the consts defined above
    Name []byte         // original string representation
    Location *Location  // text location in original source
}

// NewTerm creates a new Term
func NewTerm(x interface{}, kind int, orig []byte, file string, row int, col int) *Term {
    t := Term{Value: x, Kind: kind, Name: orig, Location: NewLocation(file, row, col)}
    return &t
}

// String prints out a string version of Term.
func (t *Term) String() string {
    return fmt.Sprintf("Term<Value: %v, Kind: %v, Name: %s>", t.Value, t.Kind, t.Name)
}

// KeyValue represents a single key-value pair for a dictionary
type KeyValue struct {
    Key *Term
    Value *Term
}

// NewKeyValue creates a key-value pair
func NewKeyValue(key *Term, value *Term) *KeyValue {
    kv := KeyValue{Key: key, Value: value}
    return &kv
}

// String converts a KeyValue into a string
func (kv *KeyValue) String() string {
    return fmt.Sprintf("KeyValue<Key: %s, Value: %s>", kv.Key, kv.Value)
}

// Equal returns T if the keys and values are the same
func (kv1 *KeyValue) Equal(kv2 *KeyValue) bool {
    return kv1.Key.Equal(kv2.Key) && kv1.Value.Equal(kv2.Value)
}

// Equal checks if two terms are equal for their Value and Kind fields.
// Ignores differences in pointers.
// Will infinite loop on circular Terms (which are never generated by the parser).
func (term1 *Term) Equal (term2 *Term) bool {
    // pointer equality
    if term1 == term2 {
        return true
    }
    // wrong types
    if term1.Kind != term2.Kind {
        return false
    }
    // recursive cases
    switch term1.Kind {
    case DICTIONARY:
        // A dictionary is a list of key/value pairs because
        //   the keys may not be simple strings in the language
        set1 := term1.Value.(*Set)
        set2 := term2.Value.(*Set)
        return set1.Equal(set2)
    case ARRAY:
        // Golang Value objs for each of the Terms' .Value fields
        arr1 := term1.Value.([]*Term)
        arr2 := term2.Value.([]*Term)
        if len(arr1) != len(arr2) {
            return false
        }
        for i := 0; i < len(arr1); i++ {
            if !arr1[i].Equal(arr2[i]) {
                return false
            }
        }
        return true
    default:
        return term1.Value == term2.Value
    }
}

// GoTerm creates a Jsonlog Term from a Go object
func GoTerm(x interface{}) *Term {
    var val interface{}
    var typ int
    switch reflect.TypeOf(x).Kind() {
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
             reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            val = float64(reflect.ValueOf(x).Int())
            typ = NUMBER
        case reflect.Float32, reflect.Float64:
            val = float64(reflect.ValueOf(x).Float())
            typ = NUMBER
        case reflect.String:
            val = x
            typ = STRING
        case reflect.Bool:
            val = x
            typ = BOOLEAN
        case reflect.Map:
            kvset := NewKeyValueSet()
            xval := reflect.ValueOf(x)
            for _, key := range xval.MapKeys() {
                kvset.Add(NewKeyValue(GoTerm(key.Interface()), GoTerm(xval.MapIndex(key).Interface())))
            }
            val = kvset
            typ = DICTIONARY
        case reflect.Slice, reflect.Array:
            xval := reflect.ValueOf(x)
            length := xval.Len()
            arr := make([]*Term, length)
            for i := 0; i < length; i++ {
                arr[i] = GoTerm(xval.Index(i).Interface())
            }
            val = arr
            typ = ARRAY
        default:
            val = x
            typ = NULL
    }
    return NewTerm(val, typ, []byte(""), "", 0, 0)
}

// returns the result of dereferencing val and
//    any pointers pointed to by val
func dePointer(val reflect.Value) reflect.Value {
    switch val.Kind() {
    case reflect.Ptr:
        return dePointer(val.Elem())
    default:
        return val
    }
}
