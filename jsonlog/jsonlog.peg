{
// Command json parses JSON as defined by [1].
//
// BUGS: the escaped forward solidus (`\/`) is not currently handled for strings.
//
// TODO: check if JSON's numbers are a subset of Go's numbers, since we are
//       assuming they are.  Currently representing all numbers as float64.
// TODO: think about relaxing a Dictionary to allow numeric keys, as they are common in practice.
// [1]: http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
package jsonlog

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

Prog <- _ vals:Term+ EOF {
    if vals == nil {
        return make([]interface{}, 0), nil
    }
    return vals.([]interface{}), nil
}

Term <- val:( Dictionary / Array / Number / String / Bool / Null ) _ {
    return val, nil
}

Dictionary <- '{' _ vals:( String _ ':' _ Term ( ',' _ String _ ':' _ Term )* )? '}' {
    valsSl := toIfaceSlice(vals)
    if len(valsSl) == 0 {
        return NewTerm([]*Term{}, DICTIONARY, c.text, "", c.pos.line, c.pos.col), nil
    }
    restSl := toIfaceSlice(valsSl[5])
    // Storing dictionary arguments as a set of KeyValue pairs since we may not be
    //   able to evaluate the keys (e.g. the key may be a variable)
    res := NewKeyValueSet()
    res.Add(NewKeyValue(valsSl[0].(*Term), valsSl[4].(*Term)))
    for _, v := range restSl {
        vSl := toIfaceSlice(v)
        res.Add(NewKeyValue(vSl[2].(*Term), vSl[6].(*Term)))
    }
    t := NewTerm(res, DICTIONARY, c.text, "", c.pos.line, c.pos.col)
    return t, nil //res, nil
}

Array <- '[' _ vals:( Value ( ',' _ Value )* )? ']' {
    valsSl := toIfaceSlice(vals)
    if len(valsSl) == 0 {
        return NewTerm([]*Term{}, ARRAY, c.text, "", c.pos.line, c.pos.col), nil
    }
    restSl := toIfaceSlice(valsSl[1])
    res := make([]*Term, 1 + len(valsSl))
    for i, v := range restSl {
        vSl := toIfaceSlice(v)
        res[i] = vSl[2].(*Term)
    }
    t := NewTerm(res, ARRAY, c.text, "", c.pos.line, c.pos.col)
    return t, nil //res, nil
}

Number <- '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    v, err := strconv.ParseFloat(string(c.text), 64)
    t := NewTerm(v, NUMBER, c.text, "", c.pos.line, c.pos.col)
    return t, err
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

Exponent <- 'e'i [+-]? DecimalDigit+

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    // TODO : the forward slash (solidus) is not a valid escape in Go, it will
    // fail if there's one in the string
    v, err := strconv.Unquote(string(c.text))
    t := NewTerm(v, STRING, c.text, "", c.pos.line, c.pos.col)
    return t, err // v, err
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

HexDigit <- [0-9a-f]i

Bool <- "true" {
    t := NewTerm(true, BOOLEAN, c.text, "", c.pos.line, c.pos.col)
    return t, nil // true, nil
} / "false" {
    t := NewTerm(false, BOOLEAN, c.text, "", c.pos.line, c.pos.col)
    return t, nil // false, nil
}

Null <- "null" {
    t := NewTerm(nil, NULL, c.text, "", c.pos.line, c.pos.col)
    return t, nil //nil, nil
}

_ "whitespace" <- [ \t\r\n]*

EOF <- !.
